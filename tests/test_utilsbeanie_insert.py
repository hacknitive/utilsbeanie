import pytest

from utilsbeanie.utilsbeanie import UtilsBeanie
from tests.sample_document import SampleDoc, SampleDocWithUniquePid
from tests.fixtures import initialize_beanie, utils_beanie, utils_beanie_unique_pid


@pytest.mark.asyncio
async def test_insert_one_without_pid(utils_beanie: UtilsBeanie):
    """
    Test inserting a document without providing a PID.
    The PID should not be set automatically.
    """
    inputs = {
        "pid":1,
        "name": "Test Insert Without PID",
        "value": 1234
    }
    inserted_doc = await utils_beanie.insert_one_without_pid(inputs)
    
    assert inserted_doc.id is not None
    assert inserted_doc.pid is not None  # PID should not be set
    assert inserted_doc.name == inputs["name"]
    assert inserted_doc.value == inputs["value"]
    
    # Verify in the database
    fetched_doc = await SampleDoc.get(inserted_doc.id)
    assert fetched_doc is not None
    assert fetched_doc.name == inputs["name"]
    assert fetched_doc.value == inputs["value"]

@pytest.mark.asyncio
async def test_insert_one_by_epoch_pid(utils_beanie_unique_pid: UtilsBeanie):
    """
    Test inserting a document with PID generated by epoch.
    Ensure that PID is set and the document is inserted correctly.
    """
    inputs = {
        "name": "Test Insert Epoch PID",
        "value": 5678
    }
    inserted_doc = await utils_beanie_unique_pid.insert_one_by_epoch_pid(inputs)
    
    assert inserted_doc.id is not None
    assert inserted_doc.pid is not None
    assert isinstance(inserted_doc.pid, int)
    assert inserted_doc.name == inputs["name"]
    assert inserted_doc.value == inputs["value"]
    
    # Verify in the database
    fetched_doc = await SampleDocWithUniquePid.find_one({"pid": inserted_doc.pid})
    assert fetched_doc is not None
    assert fetched_doc.name == inputs["name"]
    assert fetched_doc.value == inputs["value"]

# from unittest.mock import patch

# @pytest.fixture
# def mock_get_random_number():
#     with patch('utilsbeanie.utilsbeanie.utility.InsertMixin.calculate_epoch_pid') as mock:
#         yield mock


# @pytest.mark.asyncio
# async def test_insert_one_by_epoch_pid_duplicate(utils_beanie_unique_pid: UtilsBeanie, mock_get_random_number):
#     """
#     Test inserting a document with a duplicate epoch PID.
#     Expect a DuplicateKeyError to be raised.
#     """
#     # Mock 'calculate_epoch_pid' to return a fixed PID
#     fixed_pid = 1234567890
#     mock_get_random_number.return_value = fixed_pid
    
#     inputs1 = {
#         "name": "First Insert Epoch PID",
#         "value": 1111
#     }
#     inputs2 = {
#         "name": "Second Insert Epoch PID",
#         "value": 2222
#     }
    
#     # First insertion should succeed
#     inserted_doc1 = await utils_beanie_unique_pid.insert_one_by_epoch_pid(inputs1)
#     assert inserted_doc1.pid == fixed_pid
    
#     # Second insertion with the same PID should raise DuplicateKeyError
#     with pytest.raises(DuplicateKeyError):
#         await utils_beanie_unique_pid.insert_one_by_epoch_pid(inputs2)


@pytest.mark.asyncio
async def test_insert_one_without_pid_invalid_inputs(utils_beanie: UtilsBeanie):
    """
    Test inserting a document without PID with invalid inputs.
    Expect validation errors to be raised.
    """
    # Missing required fields (assuming 'name' and 'value' are required)
    invalid_inputs = {
        "name": "Invalid Insert"
        # 'value' is missing
    }
    
    with pytest.raises(ValueError):
        await utils_beanie.insert_one_without_pid(invalid_inputs)